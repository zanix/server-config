server {
	listen 80;
	# listen 443 ssl http2;
	# listen [::]:443 ssl http2;

	server_name servername.com;
	root /var/www/servername.com/;

	# Force www->none redirect.
	if ($http_host ~* "^(.+)\.servername\.com$") {
		rewrite ^ $scheme://servername.com$request_uri? permanent;
	}
	# Force redirect to SSL.
	# if ($scheme != "https") {
	# 	rewrite ^ https://$http_host$request_uri? permanent;
	# }

	# include ssl_params.conf;

	# ssl_certificate /etc/letsencrypt/live/servername.com/fullchain.pem;
	# ssl_certificate_key /etc/letsencrypt/live/servername.com/privkey.pem;

	disable_symlinks if_not_owner from=$document_root;

	# Add headers to serve security related headers
	# Before enabling Strict-Transport-Security headers please read into this topic first.
	#
	# WARNING: Only use the "preload option once you read about the consequences
	# in https://hstspreload.org/. This option will add the domain to a hardcoded
	# list that is shipped in all major browsers and getting removed from this
	# list could take several months.
	# add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";
	# add_header Strict-Transport-Security "max-age=15552000; includeSubdomains";
	add_header X-Content-Type-Options nosniff;
	add_header X-XSS-Protection "1; mode=block";
	add_header X-Robots-Tag none;
	add_header X-Download-Options noopen;
	add_header X-Permitted-Cross-Domain-Policies none;
	add_header Referrer-Policy no-referrer;
	add_header X-Frame-Options "SAMEORIGIN";

	# Remove X-Powered-By, which is an information leak.
	fastcgi_hide_header X-Powered-By;

	index index.html index.htm index.php index.xhtml;

	error_log /var/log/nginx/servername.com_error.log;
	access_log /var/log/nginx/servername.com_access.log combined;

	# Set max upload size.
	client_max_body_size 128M;


	location ~ /\. {
		deny all;
	}

	location = /favicon.ico {
		log_not_found off;
		access_log off;
		expires max;
		add_header Cache-Control "public, must-revalidate, proxy-revalidate";
	}

	location = /robots.txt {
		allow all;
		log_not_found off;
		access_log off;
	}

	# Very rarely should these ever be accessed outside of your lan.
	location ~* \.(txt|log)$ {
		deny all;
	}

	location ~ \..*/.*\.php$ {
		return 403;
	}

	location ~ ^/sites/.*/private/ {
		return 403;
	}

	# Block access to scripts in site files directory.
	location ~ ^/sites/[^/]+/files/.*\.php$ {
		deny all;
	}

	# Allow "Well-Known URIs" as per RFC 5785.
	location ~* ^/.well-known/ {
		allow all;
	}

	# Block access to "hidden" files and directories whose names begin with a
	# period. This includes directories used by version control systems such
	# as Subversion or Git to store control files.
	location ~ (^|/)\. {
			return 403;
	}

	location / {
		try_files $uri /index.php?$query_string;
	}

	location @rewrite {
		rewrite ^/(.*)$ /index.php?q=$1;
	}

	# Don't allow direct access to PHP files in the vendor directory.
	location ~ /vendor/.*\.php$ {
		deny all;
		return 404;
	}

	# In Drupal 8, we must also match new paths where the '.php' appears in
	# the middle, such as update.php/selection. The rule we use is strict,
	# and only allows this pattern with the update.php front controller.
	# This allows legacy path aliases in the form of
	# blog/index.php/legacy-path to continue to route to Drupal nodes. If
	# you do not have any paths like that, then you might prefer to use a
	# laxer rule, such as:
	#   location ~ \.php(/|$) {
	# The laxer rule will continue to work if Drupal uses this new URL
	# pattern with front controllers other than update.php in a future
	# release.
	location ~ '\.php$|^/update.php' {
		fastcgi_split_path_info ^(.+?\.php)(|/.*)$;
		include fastcgi_params;
		# Block httpoxy attacks. See https://httpoxy.org/.
		fastcgi_param HTTP_PROXY "";
		fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
		fastcgi_param PATH_INFO $fastcgi_path_info;
		fastcgi_param QUERY_STRING $query_string;
		fastcgi_pass php-handler;
	}

	# Fighting with Styles? This little gem is amazing.
	location ~ ^/sites/.*/files/styles/ {
		try_files $uri @rewrite;
	}

	# Handle private files through Drupal. Private file's path can come
	# with a language prefix.
	location ~ ^(/[a-z\-]+)?/system/files/ {
		try_files $uri /index.php?$query_string;
	}

	location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
		try_files $uri @rewrite;
		expires max;
		log_not_found off;
	}

}
